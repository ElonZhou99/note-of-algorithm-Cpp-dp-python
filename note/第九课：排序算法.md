基于比较类的排序：

- 通过比较大小来决定元素间的想对顺序
- 可以证明时间复杂度下界为O(log N)——不可能突破达到更快

非比较类排序

- 不通过比较大小来决定元素间的相对次序
- 时间复杂度受元素的范围以及分布等多种因素影响，不单纯取决于元素数量N

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gst9b5starj316e0tudj7.jpg" alt="截屏2021-07-25 下午4.05.20" style="zoom:50%;" />

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gstaafz3upj311a0isq7m.jpg" alt="截屏2021-07-25 下午4.39.18" style="zoom:50%;" />

# 比较类排序

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gst9lhbsfcj30hi0a5myl.jpg" alt="img"  />

不稳定的排序算法：快速，选择，希尔，堆排序

排序稳定性：相等的两个数，排序前和排序后的先后顺序不变则为稳定。

数组较有序——插入排序

数组较无需——快速排序

堆和归并排序最差不过O(N * log N)

==初级排序算法==

1. 直接选择——“该放哪个数了”
   - 每次从未排序数据中找最小值，放到以排序序列的末尾

2. 直接插入排序——“这个数该放哪儿”
   - 从前到后依次考虑每个未排序数据，在已排序序列中找到最合适位置插入

3. 冒泡排序
   - 不断循环扫描，每次查看相邻的元素，如逆序，则交换

4. 堆排序 O(NlogN)
   - 选择排序的优化，利用二叉堆高效地选出最小值
   - 建立一个包含所有N个元素的二叉堆
   - 重复N次从堆中取出最小值，即可得到有序序列

```C++
void heap_sort(int a[], int n) {
    priority_que<int> q;
    for (int i = 0; i < n; i++) {
        q.push(-a[i]);
    }
    for (int i = 0; i < n; i++) {
        a[i] = -q.top();
        q.pop();
    }
}
```



5. 希尔排序
   - 堆插入排序的优化，增量分组插入排序
   - 时间复杂度取决于增量序列（步长序列）的选取



6. 归并排序O(NlogN)
   - 基于分治的算法
   - 原问题：把数组排序
   - 子问题：把数组前一半，后一半分别排序
   - 合并前后有序数组





7. 快速排序O(logN)
   - 也是基于分治
     - 从数组中选取中轴元素pivot
     - 将小元素放在pivot左边，大元素放右边
     - 然后分别对左边和右边的子数组进行快排
   - 快速排序和归并排序具有相似性，但步骤顺序相反
     - 归并排序：先排序左右子数组，然后合并
     - 快速排序：先调配出左右子数组，在分别排序
   - 随机选取pivot时，期望时间复杂度是O(NlogN)
   - 快速排序可以通过适当的交换来原地实现数组的调配，避免占用额外空间
     - 最经典和高效的调配方式Hoare Partition

# 非比较类排序

1. 计数排序O(N+M)（元素个数+数值范围）
   - 要求输入的数据必须是具有确定范围的整数，将输入的数据作为key存储在额外的数组，然后依次计数大于1的填充回原数组



2. 桶排序O(N)~O(N^2)
   - 假设输入数据服从正态分布，将数据分布到有限数量的桶里，每个桶再分别排序（可能采用别的排序算法，或者以递归的方式继续使用桶排序）



3. 基数排序O(NK)（N位数字位数）
   - 把数据切割成一位位数字0-9，从地位到高位对每个位分别进行计数排序



