[TOC]
# 1. 前缀和
- 一维数组A
  - 通常将其下标变为1～n，在前面补一个0，防止计算S[r]-S[l-1]时越界
  - `nums = [0] + nums;`
- 前缀和数组S：
  - $s[i] = s[i-1] + A[i]$ // 递归思想
- 子段和——A中第l个数到第r个数的和
  - $sum(l,r) = \sum^r_{i=l}A[i]=S[r]-S[l-1]$
- A中都是非负数时，前缀和数组S单调递增
- 固定外层循环变量，考虑内层满足什么条件

==用法总结==
1. 静态区间求和
2. 关键是迭代公式
3. 扩展到前缀最小值，最大值等

# 2. 二维前缀和
- 矩阵ij的和
- 二维数组A
- 前缀和数组（==递归==）
  - $s[i][j]= \sum^i_{x=1} \sum^j_{y=1}A[x][y]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+A[i][j]$

好好体会递归二字就能理解为啥要这么写这个公式了
- 子矩阵和——$(p,q)$到$(ij)$
  - $sum(p,q,i,j)=\sum^i_{x=p}\sum^j_{y=q}A[x][y]=s[i][j]$

# 3. 差分
- 一维数组A
- 差分数组B
- $B_1=A_1,B_i=A_i-A_{i-1}(2<=i<=n)$
- 数组A的前缀和数组C，求差分后还是原数组A
- 同理差分数组B的前缀和数组就是原数组A
- 把A的第l个数到第r个数加d，B的变化为：$B_l$加$d$，$B_{r+1}$减$d$

<img src="https://tva1.sinaimg.cn/large/008i3skNly1grqc1qj7tqj30eu08wt92.jpg" alt="a" style="zoom:50%;" />
<img src="https://tva1.sinaimg.cn/large/008i3skNly1grqc5d5pe1j30rs0a4aaj.jpg" alt="截屏2021-06-22 上午12.06.15" style="zoom:50%;" />

==不理解公式？理解下面三句话==
- 任何对于区间的操作，可以转化为两个关键点（事件）
- 事件的影响 effect 从l开始，到r+1结束。开始为+，结束为-
- 最后累加影响为coEffect数组，然后求前缀和数组就是输出了


```c++
编号         1       2       3       4       5      
thing1      10             -10
thing2              20             -20
thing3              25                             -25
coEffect    10      45     -10     -20       0
ans         10      55      45      25       25
```


==还不理解？背下面的模板==
```C++
// 输入things = [l, r, effect]
vector<int> coEffect(n + 2, 0); // 累加影响数组
for (auto& thing : things){
    int l = thing[0];
    int r = thing[1];
    int effect = thing[3];
    coEffect[l] += effect;
    coEffect[r + 1] -= effcet;
}

vector<int> ans(n + 1, 0); // 前缀和数组
for (int i = 0; i <= n; i++){
    ans[i] = ans[i-1] + coEffect[i];
}
```





# 实战
- 1248-统计【优美子数组】https://leetcode-cn.com/problems/count-number-of-nice-subarrays/
  - ==两变量循环，首先分离==
  - 1. 根据奇偶性将元素转化为0/1
  - 2. 判断优美子数->>有多少子段和为k
    - 前缀和加count计数的方式
    - 滑动窗口
```C++
/*
 其下标变为1～n，在前面补一个0
 固定外层循环变量，考虑内层满足什么条件
 对于每个r(1~n)，考虑有几个l(1~r)，使得s[r] - s[l-1] = k
 对于每个i(1~n)，考虑有几个j(0~i-1)，使得s[i] - s[j] = k
 对于每个i(1~n)，考虑有几个j(0~i-1)，使得s[j] = s[i] - k
 对于每个i，有几个前缀和数组 s[j] 等于s[i] - k
 转化为在一个数组 (s) 中统计“等于某一个数”的数的数量
*/
// 其下标变为1～n，在前面补一个0,防止计算S[r]-S[l-1]时越界
// 根据奇偶性将元素转化为0/1
vector<int> s;
s[0] = 0;
for (int i = 0; i < nums.size(); i++){
    s[i+1] = nums[i] / 2;
}
// 转化为在一个数组 (s) 中统计“等于某一个数”的数的数量
// s = [0, 1, 2, 2, 2, 3]
// count = [1, 1, 3, 1]  // 1个0，1个1，3个2，1个3
vector<int> count;
for (int i = 0; i < s.size(); i++){
    count[s[i]] += 1;
}
// 对于每个i，有几个前缀和数组 s[j] 等于s[i] - k
for (int i = 0; i < s.size(); i++){
    if (s[i] - k >= 0){
        ans += count[s[i] - k];
    }
}
return ans;
```
- 304 ==模板题==二维区域和检索https://leetcode-cn.com/problems/range-sum-query-2d-immutable/
  - 先理解再背好模板！！！




- 1109 航班统计https://leetcode-cn.com/problems/corporate-flight-bookings/
  - 理解，背好模板！！！！



