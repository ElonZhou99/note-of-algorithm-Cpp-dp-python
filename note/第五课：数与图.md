[TOC]
# 1. 树、二叉树、树的遍历、树的序列化
二叉树（子节点<=2）；满二叉树；完全二叉树
**定义树的节点**
```C++
struct TreeNode{
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x)
        : val(x), left(nullptr), right(nullptr){}
}
```
**递归的本质**
- 自己调用自己，不要一直想着最后一层
- find(root) = root + find(left) + find(right)

**二叉树的遍历**
1. 前序遍历Pre-order: 根 - 左子树 - 右子数
2. 中序遍历In-order: 左子树 - 根 - 右子数
3. 后序遍历Post-order: 左子树 - 右子树 - 根
4. 层次序

**树的遍历**
- 先序、中序、后序一般用递归求
- 树的先序遍历又称树的深度优先遍历
- 层次序一般借助队列实现
- 树的层次序遍历又称树的广度优先遍历
  - 父节点出队，子节点入队


# 2. 树的直径、最近公共祖先


# 3. 树的变形（基环树）


# 4. 图、图的遍历、拓扑排序
**链表、树、图的关系**
链表是特殊化的树
树是特殊化的图
- N个点N-1条边的连通无向图——树
- N个点N条边的连通无向图——基环树

**图的存储**
邻接矩阵`[i, j]`，空间复杂度`o(n^2)`
出边数组`vector<vector>`，空间复杂度`o(点数+边数)`
邻接表
无向图看作双向图存储
有权值的图
- 邻接矩阵直接存权值
- 出边数组存`{node, val}，pair<node, val>`
```C++
// 出边数组的表示
edge = vector<vector<int>>(n, vector<int>);
edge[x].push_back(y);
```


# 实战
94 二叉树的中序遍历


589 N叉树的前序遍历

429 N叉树的层序遍历


297 二叉树的序列化与反序列化 hard

105 从前序与中序遍历序列构造二叉树 hard


236 二叉树的最近公共祖先